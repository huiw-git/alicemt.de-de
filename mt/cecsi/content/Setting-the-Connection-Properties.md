---
title: "Einstellen der Verbindungseigenschaften"
ms.custom: na
ms.date: 07/01/2016
ms.prod: sql-non-specified
ms.reviewer: na
ms.suite: na
ms.technology: 
  - drivers
ms.tgt_pltfrm: na
ms.topic: article
ms.assetid: f1b62700-f046-488d-bd6b-a5cd8fc345b7
caps.latest.revision: 154
caps.handback.revision: 137
manager: jhubbard
translation.priority.ht: 
  - de-de
  - es-es
  - fr-fr
  - it-it
  - ja-jp
  - ko-kr
  - pt-br
  - ru-ru
  - sv-se
  - zh-cn
  - zh-tw
---
# Einstellen der Verbindungseigenschaften
  Die Eigenschaften der Verbindungszeichenfolge können auf unterschiedliche Weise angegeben werden:  
  
-   Als name\=value\-Eigenschaften in der Verbindungs\-URL, wenn Sie mithilfe der DriverManager\-Klasse eine Verbindung herstellen  
  
-   Als name\=value\-Eigenschaften im *Properties*\-Parameter der Connect\-Methode in der DriverManager\-Klasse  
  
-   Als Werte in der entsprechenden Setter\-Methode der Datenquelle des Treibers Zum Beispiel:  
  
    ```  
  
    datasource.setServerName(value)  
  
    datasource.setDatabaseName(value)  
  
    ```  
  
## Hinweise  
 Bei Eigenschaftsnamen wird die Groß\-\/Kleinschreibung nicht beachtet und doppelte Eigenschaftsnamen werden in der folgenden Reihenfolge aufgelöst:  
  
1.  API\-Argumente \(z. B. Benutzer und Kennwort\)  
  
2.  Eigenschaftsauflistung  
  
3.  Letzte Instanz in der Verbindungszeichenfolge  
  
 Darüber sind unbekannte Werte für Eigenschaftsnamen zulässig und ihre Werte werden vom JDBC\-Treiber nicht auf Groß\-\/Kleinschreibung überprüft.  
  
 Synonyme sind zulässig und werden in derselben Reihenfolge wie doppelte Eigenschaftsnamen aufgelöst.  
  
 In der folgenden Tabelle werden alle derzeit verfügbaren Verbindungszeichenfolgeeigenschaften für den JDBC\-Treiber aufgelistet.  
  
|Eigenschaft|Typ|Standardwert|Beschreibung|  
|-----------------|---------|------------------|------------------|  
|applicationIntent|String|**ReadWrite**|Deklariert den Arbeitsauslastungstyp der Anwendung beim Herstellen einer Verbindung mit einem Server. Mögliche Werte sind **ReadOnly** und **ReadWrite**. Weitere Informationen finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../content/JDBC-Driver-Support-for-High-Availability--Disaster-Recovery.md).|  
|applicationName|String<br /><br /> \[\<\=128 char\]|NULL|Der Anwendungsname oder „[!INCLUDE[jdbcNoVersion](../content/includes/jdbcNoVersion_md.md)]“, wenn kein Name angegeben ist. Wird verwendet, um die jeweilige Anwendung in verschiedenen [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)]\-Profilerstellungs\- und Protokollierungstools zu identifizieren.|  
|authenticationScheme|String|„NativeAuthentication“|Gibt an, welche Art der integrierten Sicherheit von der Anwendung verwendet werden soll. Mögliche Werte sind **JavaKerberos** sowie der Standardwert **NativeAuthentication**.<br /><br /> Bei der Verwendung von **authenticationScheme\=JavaKerberos** müssen Sie den vollständig qualifizierten Domänennamen \(FQDN\) in der **serverName**\- oder **serverSpn**\-Eigenschaft angeben. Andernfalls tritt ein Fehler auf \(Server wurde in Kerberos\-Datenbank nicht gefunden\).<br /><br /> Weitere Informationen zur Verwendung von **authenticationScheme** finden Sie unter [Herstellen von Verbindungen mit SQL Server mit der integrierten Kerberos-Authentifizierung](../content/Using-Kerberos-Integrated-Authentication-to-Connect-to-SQL-Server.md).|  
|databaseName, database|String<br /><br /> \[\<\=128 char\]|NULL|Der Name der Datenbank, zu der eine Verbindung hergestellt werden soll. Ohne Angabe wird eine Verbindung zur Standarddatenbank hergestellt.|  
|disableStatementPooling|boolean<br /><br /> \["true"&#124;"false"\]|true|Nur der Wert „true“ wird derzeit unterstützt. Wenn „false“ eingestellt ist, wird eine Ausnahme ausgegeben.|  
|encrypt|boolean<br /><br /> \["true"&#124;"false"\]|false|Legen Sie „true“ fest, um anzugeben, dass [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)] die Secure Sockets Layer \(SSL\)\-Verschlüsselung für alle Daten verwendet, die zwischen dem Client und dem Server hin\- und hergesendet werden, wenn auf dem Server ein Zertifikat installiert ist. Der Standardwert ist false.|  
|failoverPartner|String|NULL|Der Name des Failoverservers, der für die Konfiguration der Datenbankspiegelung verwendet werden soll. Diese Eigenschaft wird für einen anfänglichen Verbindungsfehler mit dem Prinzipalserver verwendet. Nachdem Sie die erste Verbindung hergestellt haben, wird diese Eigenschaft ignoriert. Muss in Verbindung mit der databaseName\-Eigenschaft verwendet werden. **Note:**  Der Treiber unterstützt nicht, dass die Portnummer der Serverinstanz für die Failoverpartnerinstanz als Teil der failoverPartner\-Eigenschaft in der Verbindungszeichenfolge angegeben wird. Es wird jedoch unterstützt, dass die serverName\-, instanceName\- und portNumber\-Eigenschaften der Prinzipalserverinstanz und die failoverPartner\-Eigenschaft der Failoverpartnerinstanz in derselben Verbindungszeichenfolge angegeben werden. <br /><br /> Wenn Sie den Namen eines virtuellen Netzwerks in der **Server**\-Verbindungseigenschaft angeben, können Sie keine Datenbankspiegelung verwenden. Weitere Informationen finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../content/JDBC-Driver-Support-for-High-Availability--Disaster-Recovery.md).|  
|hostNameInCertificate|String|NULL|Der Hostname, der bei der Überprüfung des [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)]\-SSL\-Zertifikats verwendet werden soll.<br /><br /> Wenn die hostNameInCertificate\-Eigenschaft nicht angegeben oder auf NULL festgelegt ist, verwendet [!INCLUDE[jdbcNoVersion](../content/includes/jdbcNoVersion_md.md)] den **serverName**\-Eigenschaftswert auf der Verbindungs\-URL als Hostnamen, um das [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)]\-SSL\-Zertifikat zu überprüfen. **Note:**  Diese Eigenschaft wird in Kombination mit der **encrypt**\-Eigenschaft und der **trustServerCertificate**\-Eigenschaft verwendet. Diese Eigenschaft wirkt sich nur dann auf die Zertifikatsüberprüfung aus, wenn die **encrypt**\-Eigenschaft auf „true“ und die **trustServerCertificate**\-Eigenschaft auf „false“ festgelegt ist. Stellen Sie sicher, dass der an **hostNameInCertificate** übergebene Wert genau dem allgemeinen Namen \(Common Name, CN\) oder DNS\-Namen im Subjektalternativnamen \(Subject Alternate Name, SAN\) im Serverzertifikat entspricht. Nur dann kann eine SSL\-Verbindung erfolgreich hergestellt werden. Weitere Informationen finden Sie unter [Grundlegendes zur SSL-Unterstützung](../content/Understanding-SSL-Support.md).|  
|instanceName|String<br /><br /> \[\<\=128 char\]|NULL|Der [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)]\-Instanzname, mit dem eine Verbindung hergestellt wird. Ohne Angabe eines Namens wird eine Verbindung mit der Standardinstanz hergestellt. Informationen zu dem Fall, in dem sowohl instanceName als auch Port angegeben sind, finden Sie in den Hinweisen zum Port.<br /><br /> Wenn Sie den Namen eines virtuellen Netzwerks in der **Server**\-Verbindungseigenschaft angeben, können Sie keine **instanceName**\-Verbindungseigenschaft verwenden. Weitere Informationen finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../content/JDBC-Driver-Support-for-High-Availability--Disaster-Recovery.md).|  
|integratedSecurity|boolean<br /><br /> \["true"&#124;"false"\]|false|Legen Sie "true" fest, um anzugeben, dass von [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)] Windows\-Anmeldeinformationen verwendet werden, um den Benutzer der Anwendung zu authentifizieren. Wenn „true“ festgelegt ist, sucht der JDBC\-Treiber im Cache für Anmeldeinformationen des lokalen Computers nach Anmeldeinformationen, die bereits bei der Anmeldung am Computer oder im Netzwerk zur Verfügung gestellt wurden. Wenn „false“ festgelegt ist, müssen Benutzername und Kennwort angegeben werden. **Note:**  Diese Verbindungseigenschaft wird nur auf [!INCLUDE[msCoName](../content/includes/msCoName_md.md)]\-Windows\-Betriebssystemen unterstützt.|  
|lastUpdateCount|boolean<br /><br /> \["true"&#124;"false"\]|true|Wenn der Wert dieser Eigenschaft auf „true“ gesetzt ist, wird nur die letzte Updatezählung von einer SQL\-Anweisung zurückgegeben, die an den Server übergegeben wurde. Der Wert kann in einzelnen SELECT\-, INSERT\- oder DELETE\-Anweisungen verwendet werden, wenn zusätzliche Updatezählungen von Servertriggern ignoriert werden sollen. Wenn diese Eigenschaft auf „false“ gesetzt ist, werden alle Updatezählungen zurückgegeben, einschließlich der von Servertriggern. **Note:**  Diese Eigenschaft gilt nur bei Verwendung mit den [executeUpdate](../content/executeUpdate-Method--SQLServerStatement-.md)\-Methoden. Bei allen anderen execute\-Methoden werden alle Ergebnisse und Updatezählungen zurückgegeben. Diese Eigenschaft betrifft nur Updatezählungen, die von Servertriggern zurückgegeben werden. Sie betrifft keine Resultsets oder Fehler, die Folge der Ausführung eines Triggers sind.|  
|lockTimeout|int|\-1|Die Anzahl der Millisekunden, die gewartet wird, bevor die Datenbank ein Sperrtimeout meldet. Standardmäßig wird unendlich lang gewartet. Wenn angegeben, ist dieser Wert die Standardeinstellung für alle Anweisungen der Verbindung. Beachten Sie, dass  `Statement.setQueryTimeout()`  zum Festlegen des Timeouts für bestimmte Anweisungen verwendet werden kann. Der Wert kann 0 sein, was „keine Wartezeit“ angibt.|  
|loginTimeout|int \[0..65535\]|15|Die Wartezeit in Sekunden, bevor der Treiber bei einem Verbindungsfehler ein Timeout meldet. Mit dem Wert 0 wird angegeben, dass das Timeout das Standardsystemtimeout ist, das standardmäßig auf 15 Sekunden festgelegt ist. Ein Wert ungleich 0 gibt die Wartezeit in Sekunden an, bevor der Treiber bei einem Verbindungsfehler ein Timeout meldet.<br /><br /> Wenn Sie in der **Server**\-Verbindungseigenschaft den Namen eines virtuellen Netzwerks angeben, sollten Sie einen Timeoutwert von mindestens drei Minuten angeben, damit ausreichend Zeit für die Herstellung einer Failoververbindung vorhanden ist. Weitere Informationen finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../content/JDBC-Driver-Support-for-High-Availability--Disaster-Recovery.md).|  
|multiSubnetFailover|Boolean|false|Geben Sie immer **multiSubnetFailover\=true** an, wenn Sie eine Verbindung mit dem Verfügbarkeitsgruppenlistener einer [!INCLUDE[ssSQL11](../content/includes/ssSQL11_md.md)]\-Verfügbarkeitsgruppe oder einer [!INCLUDE[ssSQL11](../content/includes/ssSQL11_md.md)]\-Failoverclusterinstanz herstellen.**multiSubnetFailover\=true** konfiguriert [!INCLUDE[jdbcNoVersion](../content/includes/jdbcNoVersion_md.md)], um eine schnellere Erkennung sowie die Verbindung zum \(derzeit\) aktiven Server zu gewährleisten. Mögliche Werte sind „true“ und „false“. Weitere Informationen finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../content/JDBC-Driver-Support-for-High-Availability--Disaster-Recovery.md).<br /><br /> Sie können programmgesteuert auf die **multiSubnetFailover**\-Verbindungseigenschaft zugreifen, mithilfe von [getPropertyInfo](../content/getPropertyInfo-Method--SQLServerDriver-.md), [getMultiSubnetFailover](../content/getMultiSubnetFailover-Method--SQLServerDataSource-.md) und [setMultiSubnetFailover](../content/setMultiSubnetFailover-Method--SQLServerDataSource-.md).|  
|packetSize|int \[\-1&#124; 0 &#124; 512..32767\]|8000|Die Netzwerkpaketgröße, die zur Kommunikation mit SQL Server verwendet wird, angegeben in Bytes. Der Wert \-1 gibt an, dass die Standardpaketgröße des Servers verwendet wird. Der Wert 0 gibt an, dass der maximale Wert von 32767 verwendet wird. Wenn diese Eigenschaft auf einen Wert außerhalb des zulässigen Bereichs festgelegt ist, wird eine Ausnahme ausgelöst. **Important:**  Es wird nicht empfohlen, die packetSize\-Eigenschaft zu verwenden, wenn die Verschlüsselung aktiviert ist \(encrypt\=true\). Andernfalls könnte der Treiber einen Verbindungsfehler auslösen. Weitere Informationen finden Sie unter der [setPacketSize](../content/setPacketSize-Method--SQLServerDataSource-.md)\-Methode der [SQLServerDataSource](../content/SQLServerDataSource-Class.md)\-Klasse.|  
|Kennwort|String<br /><br /> \[\<\=128 char\]|NULL|Das Datenbankkennwort|  
|portNumber, port|int \[0..65535\]|1433|Der Port, der von [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)] überwacht wird. Wenn die Portnummer in der Verbindungszeichenfolge angegeben wird, erfolgt keine Anforderung an sqlbrowser. Wenn sowohl der Port als auch instanceName angegeben werden, wird die Verbindung mit dem angegebenen Port hergestellt. Allerdings wird **instanceName** überprüft, und wenn keine Übereinstimmung mit dem Port vorliegt, wird ein Fehler ausgelöst. **Important:**  Es wird empfohlen, immer die Portnummer anzugeben, da dies sicherer ist als die Verwendung des SQL\-Browsers.|  
|responseBuffering|String<br /><br /> \["full"&#124;"adaptive"\]|adaptive|Wenn diese Eigenschaft auf „adaptive“ festgelegt ist, werden die minimalen möglichen Daten bei Bedarf gepuffert. Der Standardmodus ist „adaptive“.<br /><br /> Wenn diese Eigenschaft auf „full“ festgelegt wird, wird das gesamte Resultset vom Server gelesen, wenn eine Anweisung ausgeführt wird. **Note:**  Nach dem Upgrade des JDBC\-Treibers von Version 1.2 ist das Standardpufferverhalten auf „adaptive“ festgelegt. Wenn bei Ihrer Anwendung die responseBuffering\-Eigenschaft nie eingestellt wurde und Sie das Standardverhalten von Version 1.2 in Ihrer Anwendung beibehalten möchten, müssen Sie die responseBuffering\-Eigenschaft auf „full“ festlegen. Dies können Sie entweder in den Verbindungseigenschaften oder mithilfe der [setResponseBuffering](../content/setResponseBuffering-Method--SQLServerStatement-.md)\-Methode des [SQLServerStatement](../content/SQLServerStatement-Class.md)\-Objekts tun.|  
|selectMethod|String<br /><br /> \["direct"&#124;"cursor"\]|Direkt|Wenn diese Eigenschaft auf „cursor“ festgelegt ist, wird für jede Abfrage, die auf der Verbindung für die Cursor TYPE\_FORWARD\_ONLY und CONCUR\_READ\_ONLY erstellt wird, ein Datenbankcursor erstellt. Diese Eigenschaft ist in der Regel nur dann erforderlich, wenn die Anwendung sehr große Resultsets generiert, die nicht vollständig in den Clientspeicher übernommen werden können. Wenn diese Eigenschaft auf „cursor“ festgelegt ist, wird nur eine begrenzte Anzahl von Resultsetzeilen in den Clientspeicher übernommen. Standardmäßig werden alle Resultsetzeilen in den Clientspeicher übernommen. Dieses Verhalten weist die schnellste Leistung auf, wenn die Anwendung alle Zeilen verarbeitet.|  
|sendStringParametersAsUnicode|boolean<br /><br /> \["true"&#124;"false"\]|true|Wenn die **sendStringParametersAsUnicode**\-Eigenschaft auf „true“ festgelegt ist, werden Zeichenfolgenparameter im Unicode\-Format an den Server gesendet.<br /><br /> Wenn die **sendStringParametersAsUnicode**\-Eigenschaft auf „false“ festgelegt ist, werden Zeichenfolgenparameter statt in Unicode in anderen Formaten, z. B. ASCII\/MBCS an den Server gesendet.<br /><br /> Der Standardwert für die **sendStringParametersAsUnicode**\-Eigenschaft ist „true“. **Note:**  Die **sendStringParametersAsUnicode**\-Eigenschaft wird nur überprüft, wenn ein Parameterwert mit **CHAR**\-, **VARCHAR**\-, oder **LONGVARCHAR**\-JDBC\-Typen gesendet wird. Die neuen JDBC 4.0\-Methoden für nationale Zeichensätze, wie z. B. setNString, setNCharacterStream, und setNClob der [SQLServerPreparedStatement](../content/SQLServerPreparedStatement-Class.md)\-Klasse und der [SQLServerCallableStatement](../content/SQLServerCallableStatement-Class.md)\-Klasse, senden ihre Werte immer im Unicode\-Format an den Server, unabhängig von der Einstellung dieser Eigenschaft. Für eine optimale Leistung mit den **CHAR**\-, **VARCHAR**\-, und **LONGVARCHAR**\-JDBC\-Datentypen sollte die **sendStringParametersAsUnicode**\-Eigenschaft bei einer Anwendung auf „false“ eingestellt sein, und es sollten die Methoden setString, setCharacterStream, und setClob für nicht nationale Zeichensätze der [SQLServerPreparedStatement](../content/SQLServerPreparedStatement-Class.md)\- und der [SQLServerCallableStatement](../content/SQLServerCallableStatement-Class.md)\-Klasse verwendet werden. Wenn bei der Anwendung die **sendStringParametersAsUnicode**\-Eigenschaft auf „false“ festgelegt wird und eine Methode für nicht nationale Zeichensätze verwendet wird, um auf Unicode\-Datentypen auf Serverseite zuzugreifen \(z. B. **nchar**, **nvarchar** und **ntext**\), können Daten verloren gehen, wenn die Datenbanksortierung die Zeichen in den Zeichenfolgenparametern, die von der Methode für nicht nationale Zeichensätze übergeben wurden, nicht unterstützt. Beachten Sie, dass eine Anwendung für die **NCHAR**\-, **NVARCHAR**\-, und **LONGNVARCHAR**\-JDBC\-Datentypen die Methoden setNString, setNCharacterStream, und setNClob für nationale Zeichenfolgen der [SQLServerPreparedStatement](../content/SQLServerPreparedStatement-Class.md)\- und der [SQLServerCallableStatement](../content/SQLServerCallableStatement-Class.md)\-Klasse verwenden sollte.|  
|sendTimeAsDatetime|boolean<br /><br /> \["true"&#124;"false"\]|true|Diese Eigenschaft wurde in [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)] JDBC Driver 3.0 hinzugefügt.<br /><br /> Wenn „true“, werden java.sql.Time\-Werte als [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)] **datetime**\-Werte an den Server gesendet.<br /><br /> Wenn „false“, werden java.sql.Time\-Werte als [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)] **time**\-Werte an den Server gesendet.<br /><br /> **sendTimeAsDatetime** kann auch mit dem [SQLServerDataSource.setSendTimeAsDatetime](../content/setSendTimeAsDatetime-Method--SQLServerDataSource-.md)\-Element programmgesteuert geändert werden.<br /><br /> In künftigen Versionen kann sich der Standardwert für diese Eigenschaft ändern.<br /><br /> Weitere Informationen darüber, wie java.sql.Time\-Werte vor dem Senden an den Server von [!INCLUDE[jdbcNoVersion](../content/includes/jdbcNoVersion_md.md)] konfiguriert werden, finden Sie unter [Konfigurieren der Art und Weise, wie java.sql.Time-Werte an den Server gesendet werden](../content/Configuring-How-java.sql.Time-Values-are-Sent-to-the-Server.md).|  
|serverName, server|String|NULL|Name des Computers, auf dem [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)] ausgeführt wird.<br /><br /> Sie können auch den Namen des virtuellen Netzwerks einer [!INCLUDE[ssHADR](../content/includes/ssHADR_md.md)]\-Verfügbarkeitsgruppe angeben. Weitere Informationen finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../content/JDBC-Driver-Support-for-High-Availability--Disaster-Recovery.md).|  
|serverSpn|String|NULL|Ab dem Microsoft JDBC Driver 4.2 für SQL Server kann diese optionale Eigenschaft verwendet werden, um den Dienstprinzipalnamen \(Service Principal Name, SPN\) für eine Java\-Kerberos\-Verbindung anzugeben.  Sie wird in Kombination mit **authenticationScheme** verwendet.<br /><br /> Der SPN kann in der Form „MSSQLSvc\/fqdn:port@REALM“ angegeben werden, wobei „fqdn“ den vollqualifizierten Domänennamen, „Port“ die Portnummer und „REALM“ den Kerberos\-Bereich des SQL Server\-Computers in Großbuchstaben darstellen.<br /><br /> Hinweis: Die Angabe „@REALM“ ist optional, wenn der Standardbereich des Clients \(gemäß Angabe in der Kerberos\-Konfiguration\) mit dem Kerberos\-Bereich des SQL Server\-Computers übereinstimmt.<br /><br /> Weitere Informationen zur Verwendung von **serverSpn** mit Java Kerberos finden Sie unter [Herstellen von Verbindungen mit SQL Server mit der integrierten Kerberos-Authentifizierung](../content/Using-Kerberos-Integrated-Authentication-to-Connect-to-SQL-Server.md).|  
|serverNameAsACE|boolean<br /><br /> \["true"&#124;"false"\]|false|Legen Sie, beginnend mit Microsoft JDBC Driver 6.0 für SQL Server, die Eigenschaft auf „true“ fest, um anzugeben, dass der Treiber für die Verbindung den Unicodeservernamen in eine ASCII\-kompatible Codierung übersetzen soll \(Punycode\). Wenn diese Einstellung auf „false“ festgelegt ist, stellt der Treiber die Verbindung unter Verwendung des vom Benutzer bereitgestellten Servernamens her.<br /><br /> Weitere Informationen finden Sie unter [Internationale Funktionen des JDBC-Treibers](../content/International-Features-of-the-JDBC-Driver.md).|  
|columnEncryptionSetting|boolean<br /><br /> \["true"&#124;"false"\]|false|Legen Sie die Eigenschaft auf „true“ fest, um das Feature „Immer verschlüsselt“ \(Always Encrypted, AE\) zu verwenden, beginnend mit Microsoft JDBC Driver 6.0 für SQL Server. Wenn AE aktiviert ist, werden vertrauliche Daten, die in verschlüsselten Datenbank\-Spalten in SQL Server gespeichert sind, vom JDBC\-Treiber transparent verschlüsselt und entschlüsselt.<br /><br /> Weitere Informationen finden Sie unter [Verwenden von „Immer verschlüsselt“ mit dem JDBC-Treiber](../content/Using-Always-Encrypted-with-the-JDBC-Driver.md). **Note:**  AE ist mit SQL Server 2016 \(Vorschau\) oder neueren Versionen verfügbar.|  
|trustServerCertificate|boolean<br /><br /> \["true"&#124;"false"\]|false|Legen Sie die Eigenschaft auf „true“ fest, um anzugeben, dass [!INCLUDE[jdbcNoVersion](../content/includes/jdbcNoVersion_md.md)] das [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)]\-SSL\-Zertifikat nicht überprüft.<br /><br /> Wenn „true“, gilt das [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)]\-SSL\-Zertifikat automatisch als vertrauenswürdig, wenn die Kommunikationsebene mittels SSL verschlüsselt wird.<br /><br /> Wenn „false“, überprüft [!INCLUDE[jdbcNoVersion](../content/includes/jdbcNoVersion_md.md)] das SSL\-Serverzertifikat. Schlägt die Überprüfung des Serverzertifikats fehl, löst der Treiber einen Fehler aus und die beendet die Verbindung. Der Standardwert lautet "false". Stellen Sie sicher, dass der an **serverName** übergebene Wert genau dem allgemeinen Namen \(Common Name, CN\) oder DNS\-Namen im Subjektalternativnamen im Serverzertifikat entspricht. Nur dann kann eine SSL\-Verbindung erfolgreich hergestellt werden. Weitere Informationen finden Sie unter [Grundlegendes zur SSL-Unterstützung](../content/Understanding-SSL-Support.md). **Note:**  Diese Eigenschaft wird in Kombination mit der **encrypt**\-Eigenschaft verwendet. Diese Eigenschaft wirkt sich nur dann auf die SSL Serverzertifikatsüberprüfung aus, wenn die **encrypt**\-Eigenschaft auf „true“ festgelegt ist.|  
|trustStore|String|NULL|Der Pfad \(einschließlich Dateiname\) zur trustStore\-Zertifikatsdatei. Die trustStore\-Datei enthält die Liste der Zertifikate, denen der Client vertraut.<br /><br /> Wenn diese Eigenschaft nicht angegeben oder auf NULL festgelegt ist, verwendet der Treiber die Suchregeln der Trust\-Manager\-Factory, um den zu verwendenden Zertifikatspeicher zu ermitteln.<br /><br /> Die Standard\-SunX509 TrustManagerFactory versucht, die vertrauenswürdigen Informationen in der folgenden Suchreihenfolge zu finden:<br /><br /> -   Eine von der Java Virtual Machine \(JVM\)\-Systemeigenschaft „javax.net.ssl.trustStore“ angegebene Datei.<br />-   Datei "\<java\-home\>\/lib\/security\/jssecacerts".<br />-   Datei "\<java\-home\>\/lib\/security\/jssecacerts".<br /><br /> Weitere Informationen finden Sie in der Dokumentation zur SUNX509 TrustManager\-Schnittstelle auf der Sun Microsystems\-Website. **Note:**  Die trustStorePassword\-Eigenschaft hat nur dann Auswirkungen auf die Suche nach „trustStore“ für das Zertifikat, wenn die **encrypt**\-Eigenschaft auf „true“ und die **trustServerCertificate**\-Eigenschaft auf „false“ festgelegt ist.|  
|trustStorePassword|String|NULL|Das Kennwort, das verwendet wird, um die Integrität der trustStore\-Daten zu überprüfen.<br /><br /> Wenn die trustStore\-Eigenschaft festgelegt ist, aber die trustStorePassword\-Eigenschaft nicht festgelegt ist, wird die Integrität von „trustStore“ nicht überprüft.<br /><br /> Wenn sowohl die trustStore\- als auch die TrustStorePassword\-Eigenschaft nicht angegeben wurde, verwendet der Treiber die JVM\-Systemeigenschaften „javax.net.ssl.trustStore“ und „javax.net.ssl.trustStorePassword“. Wenn die Systemeigenschaft „javax.net.ssl.trustStorePassword“ nicht angegeben ist, wird die Integrität von „trustStore“ nicht überprüft.<br /><br /> Wenn die trustStore\-Eigenschaft nicht festgelegt ist, die trustStorePassword\-Eigenschaft jedoch festgelegt ist, verwendet der JDBC\-Treiber die von „javax.net.ssl.trustStore“ angegebene Datei als Vertrauensspeicher, und die Integrität des Vertrauensspeichers wird mithilfe des angegebenen „trustStorePassword“ überprüft. Dies kann erforderlich sein, wenn in der Clientanwendung das Kennwort nicht in der JVM\-Systemeigenschaft gespeichert werden soll. **Note:**  Die trustStorePassword\-Eigenschaft hat nur dann Auswirkungen auf die Suche nach „trustStore“ für das Zertifikat, wenn die **encrypt**\-Eigenschaft auf „true“ und die **trustServerCertificate**\-Eigenschaft auf „false“ festgelegt ist.|  
|userName, user|String<br /><br /> \[\<\=128 char\]|NULL|Der Datenbankbenutzer.|  
|workstationID|String<br /><br /> \[\<\=128 char\]|\<leere Zeichenfolge\>|Die ID der Arbeitsstation. Wird verwendet, um die jeweilige Arbeitsstation in verschiedenen [!INCLUDE[ssNoVersion](../content/includes/ssNoVersion_md.md)]\-Profilerstellungs\- und Protokollierungstools zu identifizieren. Wenn keine Angabe erfolgt, wird die \<leere Zeichenfolge\> verwendet.|  
|xopenStates|boolean<br /><br /> \["true"&#124;"false"\]|false|Legen Sie die Eigenschaft auf „true“ fest, um anzugeben, dass der Treiber in Ausnahmen XOPEN\-kompatible Statuscodes zurückgibt. Standardmäßig werden SQL 99\-Statuscodes zurückgegeben.|  
  
> [!NOTE]  
>  [!INCLUDE[jdbcNoVersion](../content/includes/jdbcNoVersion_md.md)] akzeptiert die standardmäßigen Serverwerte für Verbindungseigenschaften, außer ANSI\_DEFAULTS und IMPLICIT\_TRANSACTIONS.[!INCLUDE[jdbcNoVersion](../content/includes/jdbcNoVersion_md.md)] legt ANSI\_DEFAULTS automatisch auf ON und IMPLICIT\_TRANSACTIONS auf OFF fest.  
  
## Siehe auch  
 [Verbinden von SQL Server mit dem JDBC-Treiber](../content/Connecting-to-SQL-Server-with-the-JDBC-Driver.md)  
  
  